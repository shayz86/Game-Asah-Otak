<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Flow Master</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&display=swap');

        /* --- 1. LAYOUT UTAMA (Flex Center) --- */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            height: 100dvh;
            overflow: hidden;
            background-color: #0f172a; /* Slate 900 */
            color: #e2e8f0;
            font-family: 'Fredoka', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            touch-action: none; /* Mencegah scroll saat main */
            user-select: none;
        }

        /* --- 2. SISTEM LAYAR (Saklar) --- */
        .game-screen {
            display: none !important;
            width: 100%;
            max-width: 480px; /* Batas lebar HP */
            height: 100%;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            box-sizing: border-box;
            position: relative;
        }

        .game-screen.active {
            display: flex !important;
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn { from { opacity: 0; transform: scale(0.98); } to { opacity: 1; transform: scale(1); } }

        /* --- 3. STYLING KHUSUS --- */
        canvas {
            border-radius: 16px;
            box-shadow: 0 10px 30px -5px rgba(0, 0, 0, 0.5);
            background: #1e293b;
            cursor: crosshair;
            touch-action: none;
        }

        .btn-glow {
            animation: pulse-glow 2s infinite;
        }
        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 15px rgba(59, 130, 246, 0.4); }
            50% { box-shadow: 0 0 25px rgba(59, 130, 246, 0.7); }
        }

        .hide-scroll::-webkit-scrollbar { display: none; }
        
        .floating-bg {
            position: absolute;
            width: 150px; height: 150px;
            border-radius: 50%;
            filter: blur(80px);
            opacity: 0.3;
            z-index: 0;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div class="floating-bg bg-blue-500 top-10 left-10"></div>
    <div class="floating-bg bg-pink-500 bottom-10 right-10"></div>

    <div id="screen-menu" class="game-screen active z-50">
        
        <a href="../index.html" class="absolute top-6 left-6 text-slate-400 hover:text-white flex items-center gap-2 font-semibold transition no-underline z-50 bg-slate-800/50 px-3 py-1 rounded-full">
            <i class="fas fa-arrow-left"></i> Menu
        </a>

        <div class="mb-10 text-center relative z-10">
            <h1 class="text-6xl font-bold tracking-tighter drop-shadow-2xl mb-1">
                <span class="text-blue-500">FLOW</span>
            </h1>
            <h1 class="text-6xl font-bold tracking-tighter drop-shadow-2xl">
                <span class="text-pink-500">MASTER</span>
            </h1>
            <div class="mt-4">
                <span class="bg-slate-800 px-3 py-1 rounded-full text-xs font-bold border border-slate-700 text-slate-400">CHALLENGE EDITION</span>
            </div>
        </div>

        <div class="w-full max-w-xs space-y-4 relative z-10">
            <button id="btn-play" class="w-full bg-gradient-to-r from-blue-600 to-blue-500 text-white py-4 rounded-2xl font-bold text-xl shadow-xl btn-glow border-b-4 border-blue-800 flex items-center justify-center gap-3 active:scale-95 transition">
                <i class="fas fa-play"></i> MAINKAN
            </button>
            
            <button id="btn-leaderboard" class="w-full bg-slate-700 hover:bg-slate-600 text-white py-4 rounded-2xl font-bold text-lg shadow-lg border-b-4 border-slate-900 flex items-center justify-center gap-3 active:scale-95 transition">
                <i class="fas fa-trophy text-yellow-500"></i> LIHAT REKOR
            </button>
        </div>
        
        <div class="mt-8 text-slate-600 text-xs font-mono relative z-10">v2.0 â€¢ FIXED CONTROLS</div>
    </div>


    <div id="screen-game" class="game-screen z-40">
        <div class="w-full flex justify-between items-center mb-4">
            <button id="btn-home" class="w-10 h-10 bg-slate-800 rounded-full text-slate-400 border border-slate-700 flex items-center justify-center active:scale-90 transition">
                <i class="fas fa-home"></i>
            </button>
            
            <div class="flex gap-3 text-sm font-bold">
                <div class="bg-slate-800 px-3 py-1 rounded-full border border-slate-700">
                    LVL <span id="level-display" class="text-white ml-1">1</span>
                </div>
                <div class="bg-slate-800 px-3 py-1 rounded-full border border-slate-700">
                    MOVES <span id="moves-display" class="text-blue-400 ml-1">0</span>
                </div>
            </div>
            
            <button id="btn-reset" class="w-10 h-10 bg-slate-800 rounded-full text-slate-400 border border-slate-700 flex items-center justify-center active:scale-90 transition">
                <i class="fas fa-undo"></i>
            </button>
        </div>

        <div class="relative shadow-2xl rounded-2xl p-2 bg-slate-800/50 border border-slate-700">
            <canvas id="gameCanvas" width="350" height="350"></canvas>
            
            <div id="level-overlay" class="absolute inset-0 bg-slate-900/90 backdrop-blur-sm rounded-2xl flex flex-col items-center justify-center hidden">
                <i class="fas fa-check-circle text-6xl text-emerald-500 mb-4 animate-bounce"></i>
                <h2 class="text-2xl font-bold text-white mb-4">Level Selesai!</h2>
                <button id="btn-next-level" class="bg-emerald-500 text-white px-8 py-3 rounded-full font-bold shadow-lg active:scale-95 transition">
                    Lanjut <i class="fas fa-arrow-right ml-2"></i>
                </button>
            </div>
        </div>

        <div class="mt-6 text-center text-slate-500 text-xs">
            Hubungkan warna yang sama untuk mengisi seluruh kotak
        </div>
    </div>


    <div id="screen-leaderboard" class="game-screen z-50">
        <h2 class="text-2xl font-bold text-yellow-500 mb-6 flex items-center gap-2">
            <i class="fas fa-trophy"></i> Top Skor
        </h2>
        
        <div class="bg-slate-800 w-full rounded-2xl border border-slate-700 overflow-hidden flex flex-col shadow-2xl h-[60vh]">
            <div class="grid grid-cols-3 bg-slate-900 p-4 font-bold text-xs uppercase text-slate-400">
                <div class="text-center">Rank</div>
                <div>Player</div>
                <div class="text-right">Level</div>
            </div>
            <div id="leaderboard-list" class="overflow-y-auto p-0 flex-1 hide-scroll"></div>
        </div>
        
        <button id="btn-close-lb" class="mt-6 px-10 py-3 bg-slate-700 rounded-full font-bold text-white shadow-lg active:scale-95 transition">
            TUTUP
        </button>
    </div>

    <script>
        /* --- CONFIG & LEVELS --- */
        const CONFIG = {
            colors: {
                1: '#ef4444', 2: '#3b82f6', 3: '#22c55e', 4: '#eab308', 
                5: '#d946ef', 6: '#f97316', 7: '#06b6d4', 8: '#94a3b8'
            },
            gridLine: '#334155',
            bg: '#1e293b'
        };

        // Format: 0=Empty, 1-8=Color IDs
        const LEVELS = [
            { size: 5, grid: [[1,0,0,0,2],[0,0,0,0,2],[0,3,3,0,0],[4,0,0,0,0],[4,0,1,5,5]] },
            { size: 5, grid: [[4,4,0,0,1],[0,0,3,0,0],[1,0,3,0,0],[5,0,0,0,0],[5,0,0,2,2]] },
            { size: 6, grid: [[1,0,0,2,0,0],[0,0,0,2,0,0],[0,3,4,0,0,0],[0,3,4,0,5,0],[0,0,0,0,5,0],[1,0,0,0,0,0]] },
            { size: 6, grid: [[1,0,0,0,0,1],[0,0,3,3,0,0],[0,0,4,4,0,0],[0,0,0,0,2,2],[0,5,5,0,0,0],[0,0,0,0,0,0]] },
            { size: 7, grid: [[1,0,0,0,0,0,2],[0,0,3,0,0,0,2],[0,0,3,0,4,0,0],[0,5,0,0,4,0,0],[0,5,0,0,0,0,6],[0,0,0,0,0,0,6],[1,0,0,0,0,0,0]] }
        ];

        /* --- GAME STATE --- */
        let state = {
            levelIdx: 0,
            grid: [],
            paths: {}, // { colorId: [{r, c}, ...] }
            currentPath: null, // colorId being drawn
            moves: 0,
            completed: false
        };
        
        let canvas, ctx;
        let cellSize, gridSize;

        /* --- INITIALIZATION --- */
        document.addEventListener('DOMContentLoaded', () => {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            // Attach Listeners
            document.getElementById('btn-play').onclick = startGame;
            document.getElementById('btn-leaderboard').onclick = showLeaderboard;
            document.getElementById('btn-close-lb').onclick = () => switchScreen('screen-menu');
            document.getElementById('btn-home').onclick = () => switchScreen('screen-menu');
            document.getElementById('btn-reset').onclick = resetLevel;
            document.getElementById('btn-next-level').onclick = nextLevel;
            
            // Canvas Inputs
            canvas.addEventListener('mousedown', handleStart);
            canvas.addEventListener('mousemove', handleMove);
            window.addEventListener('mouseup', handleEnd);
            
            canvas.addEventListener('touchstart', (e) => handleStart(e.touches[0]));
            canvas.addEventListener('touchmove', (e) => { e.preventDefault(); handleMove(e.touches[0]); });
            window.addEventListener('touchend', handleEnd);
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
        });

        function switchScreen(id) {
            document.querySelectorAll('.game-screen').forEach(el => el.classList.remove('active'));
            document.getElementById(id).classList.add('active');
            if(id === 'screen-game') resizeCanvas();
        }

        function resizeCanvas() {
            const size = Math.min(window.innerWidth - 48, 400);
            canvas.width = size;
            canvas.height = size;
            canvas.style.width = size + 'px';
            canvas.style.height = size + 'px';
            if(state.grid.length > 0) render();
        }

        /* --- GAME LOGIC --- */
        function startGame() {
            state.levelIdx = 0;
            loadLevel(0);
            switchScreen('screen-game');
        }

        function loadLevel(idx) {
            if(idx >= LEVELS.length) {
                alert("Selamat! Semua level selesai.");
                switchScreen('screen-menu');
                return;
            }
            
            const lvl = LEVELS[idx];
            gridSize = lvl.size;
            cellSize = canvas.width / gridSize;
            
            // Deep copy grid
            state.grid = JSON.parse(JSON.stringify(lvl.grid));
            state.paths = {};
            state.moves = 0;
            state.completed = false;
            
            // Initialize paths with starting points
            for(let r=0; r<gridSize; r++) {
                for(let c=0; c<gridSize; c++) {
                    const val = state.grid[r][c];
                    if(val > 0) {
                        if(!state.paths[val]) state.paths[val] = [];
                        // Store endpoints but don't connect them yet
                    }
                }
            }
            
            document.getElementById('level-display').innerText = idx + 1;
            document.getElementById('moves-display').innerText = 0;
            document.getElementById('level-overlay').classList.add('hidden');
            
            render();
        }

        function resetLevel() {
            loadLevel(state.levelIdx);
        }

        function nextLevel() {
            state.levelIdx++;
            loadLevel(state.levelIdx);
        }

        /* --- INPUT HANDLING --- */
        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const c = Math.floor(x / cellSize);
            const r = Math.floor(y / cellSize);
            return {r, c};
        }

        function handleStart(e) {
            if(state.completed) return;
            const p = getPos(e);
            if(isOutOfBounds(p)) return;
            
            const val = LEVELS[state.levelIdx].grid[p.r][p.c]; // Check base grid
            const currentVal = state.grid[p.r][p.c]; // Check current state
            
            // Start drawing if clicked on endpoint OR existing path
            let colorId = val || currentVal;
            
            if(colorId > 0) {
                state.currentPath = colorId;
                state.paths[colorId] = [{r: p.r, c: p.c}]; // Start fresh path
                updateGridFromPaths();
                render();
            }
        }

        function handleMove(e) {
            if(!state.currentPath || state.completed) return;
            const p = getPos(e);
            if(isOutOfBounds(p)) return;
            
            const path = state.paths[state.currentPath];
            const last = path[path.length-1];
            
            // If moved to new cell
            if(last.r !== p.r || last.c !== p.c) {
                // Check connectivity (must be adjacent)
                if(Math.abs(last.r - p.r) + Math.abs(last.c - p.c) === 1) {
                    
                    // Check collision with other paths
                    const targetBase = LEVELS[state.levelIdx].grid[p.r][p.c];
                    const targetCurrent = state.grid[p.r][p.c];
                    
                    // Allow if empty, or own color endpoint
                    if((targetCurrent === 0) || (targetBase === state.currentPath) || (targetCurrent === state.currentPath)) {
                        
                        // Backtracking logic
                        const index = path.findIndex(pt => pt.r === p.r && pt.c === p.c);
                        if(index !== -1) {
                            state.paths[state.currentPath] = path.slice(0, index+1);
                        } else {
                            // Prevent crossing completed endpoints of other colors
                            if(targetBase !== 0 && targetBase !== state.currentPath) return;
                            
                            path.push({r: p.r, c: p.c});
                        }
                        
                        updateGridFromPaths();
                        render();
                        checkWin();
                    }
                }
            }
        }

        function handleEnd() {
            if(state.currentPath) {
                state.moves++;
                document.getElementById('moves-display').innerText = state.moves;
                state.currentPath = null;
                checkWin();
            }
        }

        function isOutOfBounds(p) {
            return p.r < 0 || p.r >= gridSize || p.c < 0 || p.c >= gridSize;
        }

        function updateGridFromPaths() {
            // Reset grid to base level
            const base = LEVELS[state.levelIdx].grid;
            // Clear dynamic paths
            for(let r=0; r<gridSize; r++) {
                for(let c=0; c<gridSize; c++) {
                    if(base[r][c] === 0) state.grid[r][c] = 0;
                }
            }
            
            // Draw paths onto grid
            for(const [colorId, path] of Object.entries(state.paths)) {
                path.forEach(pt => {
                    state.grid[pt.r][pt.c] = parseInt(colorId);
                });
            }
        }

        /* --- RENDERER --- */
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw Grid Lines
            ctx.strokeStyle = CONFIG.gridLine;
            ctx.lineWidth = 1;
            ctx.beginPath();
            for(let i=0; i<=gridSize; i++) {
                const pos = i * cellSize;
                ctx.moveTo(pos, 0); ctx.lineTo(pos, canvas.height);
                ctx.moveTo(0, pos); ctx.lineTo(canvas.width, pos);
            }
            ctx.stroke();
            
            // Draw Paths
            for(const [colorId, path] of Object.entries(state.paths)) {
                if(path.length < 2) continue;
                
                ctx.strokeStyle = CONFIG.colors[colorId];
                ctx.lineWidth = cellSize * 0.4;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                // Add Glow
                ctx.shadowBlur = 10;
                ctx.shadowColor = CONFIG.colors[colorId];
                
                ctx.beginPath();
                ctx.moveTo(path[0].c * cellSize + cellSize/2, path[0].r * cellSize + cellSize/2);
                for(let i=1; i<path.length; i++) {
                    ctx.lineTo(path[i].c * cellSize + cellSize/2, path[i].r * cellSize + cellSize/2);
                }
                ctx.stroke();
                
                // Reset Glow
                ctx.shadowBlur = 0;
            }
            
            // Draw Endpoints (Base Level)
            const base = LEVELS[state.levelIdx].grid;
            for(let r=0; r<gridSize; r++) {
                for(let c=0; c<gridSize; c++) {
                    const val = base[r][c];
                    if(val > 0) {
                        const cx = c * cellSize + cellSize/2;
                        const cy = r * cellSize + cellSize/2;
                        
                        ctx.fillStyle = CONFIG.colors[val];
                        
                        // Check if connected
                        const path = state.paths[val];
                        const isConnected = path && path.some(pt => pt.r === r && pt.c === c);
                        
                        ctx.beginPath();
                        ctx.arc(cx, cy, cellSize * (isConnected ? 0.35 : 0.25), 0, Math.PI*2);
                        ctx.fill();
                        
                        if(isConnected) {
                            ctx.fillStyle = '#fff';
                            ctx.beginPath();
                            ctx.arc(cx, cy, cellSize * 0.1, 0, Math.PI*2);
                            ctx.fill();
                        }
                    }
                }
            }
        }

        /* --- WIN LOGIC --- */
        function checkWin() {
            let allConnected = true;
            let filledCount = 0;
            const base = LEVELS[state.levelIdx].grid;
            
            // Get all required colors
            const requiredColors = new Set();
            base.forEach(r => r.forEach(v => { if(v>0) requiredColors.add(v); }));
            
            for(let colorId of requiredColors) {
                const path = state.paths[colorId];
                if(!path) { allConnected = false; break; }
                
                // Find the two endpoints for this color
                const endpoints = [];
                for(let r=0; r<gridSize; r++) {
                    for(let c=0; c<gridSize; c++) {
                        if(base[r][c] === colorId) endpoints.push({r,c});
                    }
                }
                
                // Check if path connects both endpoints
                const start = path[0];
                const end = path[path.length-1];
                
                co
