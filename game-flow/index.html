<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Flow Master</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&display=swap" rel="stylesheet">
    
    <style>
        /* --- 1. LAYOUT UTAMA (Sama persis dengan Color Chaos V5) --- */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            height: 100dvh;
            overflow: hidden;
            background-color: #0f172a; /* Slate 900 */
            font-family: 'Fredoka', sans-serif;
            color: white;
            
            /* POSISI TENGAH MUTLAK */
            display: flex;
            justify-content: center;
            align-items: center;
            
            /* PENTING: User select none agar tidak blok biru saat tahan tombol */
            user-select: none;
            -webkit-user-select: none;
        }

        /* Container HP */
        #app-frame {
            width: 100%;
            max-width: 480px;
            height: 100%;
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        /* --- 2. SISTEM LAYAR (Saklar V5) --- */
        .game-screen {
            display: none !important;
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 24px;
            z-index: 10;
        }

        .game-screen.active {
            display: flex !important;
            z-index: 20;
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        /* --- 3. CANVAS KHUSUS --- */
        canvas {
            background: #1e293b;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            /* Touch Action None: Agar browser tidak scroll saat menggambar */
            touch-action: none; 
            cursor: crosshair;
        }

        /* --- 4. TOMBOL ANTI-MACET --- */
        .btn-action {
            cursor: pointer;
            transition: transform 0.1s, opacity 0.1s;
            position: relative;
            z-index: 50; /* Pastikan tombol di atas segalanya */
        }
        .btn-action:active {
            transform: scale(0.95);
            opacity: 0.9;
        }

        /* Styling Judul */
        .text-gradient {
            background: linear-gradient(to right, #3b82f6, #ec4899);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .hide-scroll::-webkit-scrollbar { display: none; }
    </style>
</head>
<body>

    <div id="app-frame">

        <div id="screen-menu" class="game-screen active">
            <a href="../index.html" class="absolute top-6 left-6 text-slate-400 hover:text-white flex items-center gap-2 font-semibold no-underline bg-slate-800/50 px-3 py-1 rounded-full z-50 pointer-events-auto">
                <i class="fas fa-arrow-left"></i> Menu
            </a>

            <div class="mb-12 text-center">
                <h1 class="text-6xl font-bold tracking-tighter drop-shadow-2xl mb-1">
                    <span class="text-blue-500">FLOW</span>
                </h1>
                <h1 class="text-6xl font-bold tracking-tighter drop-shadow-2xl">
                    <span class="text-pink-500">MASTER</span>
                </h1>
                <div class="mt-4">
                    <span class="bg-slate-800 px-3 py-1 rounded-full text-xs font-bold border border-slate-700 text-slate-400">PUZZLE EDITION</span>
                </div>
            </div>

            <div class="w-full max-w-xs space-y-4">
                <button id="btn-play" class="btn-action w-full bg-gradient-to-r from-blue-600 to-blue-500 text-white py-4 rounded-2xl font-bold text-xl shadow-xl border-b-4 border-blue-800 flex items-center justify-center gap-3">
                    <i class="fas fa-play"></i> MAINKAN
                </button>
                
                <button id="btn-leaderboard" class="btn-action w-full bg-slate-700 text-white py-4 rounded-2xl font-bold text-lg shadow-lg border-b-4 border-slate-900 flex items-center justify-center gap-3">
                    <i class="fas fa-trophy text-yellow-500"></i> TOP SKOR
                </button>
            </div>
            
            <div class="mt-8 text-slate-600 text-xs font-mono">v5.0 â€¢ HYBRID INPUT ENGINE</div>
        </div>


        <div id="screen-game" class="game-screen">
            <div class="w-full flex justify-between items-center mb-4">
                <button id="btn-home" class="btn-action w-10 h-10 bg-slate-800 rounded-full text-slate-400 border border-slate-700 flex items-center justify-center">
                    <i class="fas fa-home"></i>
                </button>
                
                <div class="flex gap-3 text-sm font-bold">
                    <div class="bg-slate-800 px-3 py-1 rounded-full border border-slate-700">
                        LVL <span id="level-display" class="text-white ml-1">1</span>
                    </div>
                    <div class="bg-slate-800 px-3 py-1 rounded-full border border-slate-700">
                        MOVES <span id="moves-display" class="text-blue-400 ml-1">0</span>
                    </div>
                </div>
                
                <button id="btn-reset" class="btn-action w-10 h-10 bg-slate-800 rounded-full text-slate-400 border border-slate-700 flex items-center justify-center">
                    <i class="fas fa-undo"></i>
                </button>
            </div>

            <div class="relative shadow-2xl rounded-2xl p-2 bg-slate-800/50 border border-slate-700">
                <canvas id="gameCanvas" width="350" height="350"></canvas>
                
                <div id="level-overlay" class="absolute inset-0 bg-slate-900/95 backdrop-blur-sm rounded-2xl flex flex-col items-center justify-center hidden z-50">
                    <i class="fas fa-check-circle text-6xl text-emerald-500 mb-4 animate-bounce"></i>
                    <h2 class="text-2xl font-bold text-white mb-4">Level Selesai!</h2>
                    <button id="btn-next" class="btn-action bg-emerald-500 text-white px-8 py-3 rounded-full font-bold shadow-lg border-b-4 border-emerald-700">
                        Lanjut <i class="fas fa-arrow-right ml-2"></i>
                    </button>
                </div>
            </div>

            <div class="mt-6 text-center text-slate-500 text-xs">
                Tarik garis untuk menghubungkan warna yang sama
            </div>
        </div>


        <div id="screen-leaderboard" class="game-screen">
            <h2 class="text-2xl font-bold text-yellow-500 mb-6 flex items-center gap-2">
                <i class="fas fa-trophy"></i> Top Skor
            </h2>
            
            <div class="bg-slate-800 w-full rounded-2xl border border-slate-700 overflow-hidden flex flex-col shadow-2xl h-[60vh]">
                <div class="grid grid-cols-3 bg-slate-900 p-4 font-bold text-xs uppercase text-slate-400">
                    <div class="text-center">Rank</div>
                    <div>Player</div>
                    <div class="text-right">Level</div>
                </div>
                <div id="leaderboard-list" class="overflow-y-auto p-0 flex-1 hide-scroll"></div>
            </div>
            
            <button id="btn-close-lb" class="btn-action mt-6 px-10 py-3 bg-slate-700 rounded-full font-bold text-white shadow-lg border-b-4 border-slate-900">
                TUTUP
            </button>
        </div>

    </div>

    <script>
        /* --- 1. CONFIGURATION --- */
        const CONFIG = {
            colors: {
                1: '#ef4444', 2: '#3b82f6', 3: '#22c55e', 4: '#eab308', 
                5: '#d946ef', 6: '#f97316', 7: '#06b6d4', 8: '#94a3b8'
            },
            gridLine: '#334155',
            bg: '#1e293b'
        };

        const LEVELS = [
            { size: 5, grid: [[1,0,0,0,2],[0,0,0,0,2],[0,3,3,0,0],[4,0,0,0,0],[4,0,1,5,5]] },
            { size: 5, grid: [[4,4,0,0,1],[0,0,3,0,0],[1,0,3,0,0],[5,0,0,0,0],[5,0,0,2,2]] },
            { size: 6, grid: [[1,0,0,2,0,0],[0,0,0,2,0,0],[0,3,4,0,0,0],[0,3,4,0,5,0],[0,0,0,0,5,0],[1,0,0,0,0,0]] },
            { size: 6, grid: [[1,0,0,0,0,1],[0,0,3,3,0,0],[0,0,4,4,0,0],[0,0,0,0,2,2],[0,5,5,0,0,0],[0,0,0,0,0,0]] },
            { size: 7, grid: [[1,0,0,0,0,0,2],[0,0,3,0,0,0,2],[0,0,3,0,4,0,0],[0,5,0,0,4,0,0],[0,5,0,0,0,0,6],[0,0,0,0,0,0,6],[1,0,0,0,0,0,0]] }
        ];

        /* --- 2. STATE VARIABLES --- */
        let state = {
            levelIdx: 0,
            grid: [],
            paths: {},
            currentPath: null,
            moves: 0,
            completed: false
        };
        let canvas, ctx, cellSize, gridSize;

        /* --- 3. HELPER: BUTTON BINDER (Tombol Pasti Jalan) --- */
        function bindButton(id, callback) {
            const btn = document.getElementById(id);
            if(!btn) return;

            // Handler untuk Touch (HP)
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault(); // Mencegah ghost click
                callback();
            }, {passive: false});

            // Handler untuk Click (PC/Mouse)
            btn.addEventListener('click', (e) => {
                e.preventDefault();
                callback();
            });
        }

        /* --- 4. SYSTEM INITIALIZATION --- */
        document.addEventListener('DOMContentLoaded', () => {
            // Binding Tombol dengan Sistem Aman
            bindButton('btn-play', startGame);
            bindButton('btn-leaderboard', showLeaderboard);
            bindButton('btn-close-lb', () => switchScreen('screen-menu'));
            bindButton('btn-home', () => switchScreen('screen-menu'));
            bindButton('btn-reset', resetLevel);
            bindButton('btn-next', nextLevel);

            // Setup Canvas
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            // Event Canvas (Drawing)
            canvas.addEventListener('mousedown', handleStart);
            canvas.addEventListener('mousemove', handleMove);
            window.addEventListener('mouseup', handleEnd);
            
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault(); // PENTING: Mencegah scroll saat menggambar
                handleStart(e.touches[0]);
            }, {passive: false});
            
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault(); // PENTING: Mencegah scroll saat menggambar
                handleMove(e.touches[0]);
            }, {passive: false});
            
            window.addEventListener('touchend', handleEnd);
            window.addEventListener('resize', resizeCanvas);
        });

        /* --- 5. SCREEN LOGIC --- */
        function switchScreen(id) {
            document.querySelectorAll('.game-screen').forEach(el => el.classList.remove('active'));
            document.getElementById(id).classList.add('active');
            if(id === 'screen-game') {
                setTimeout(resizeCanvas, 50); // Pastikan ukuran canvas benar
            }
        }

        /* --- 6. GAME LOGIC --- */
        function startGame() {
            state.levelIdx = 0;
            loadLevel(0);
            switchScreen('screen-game');
        }

        function loadLevel(idx) {
            if(idx >= LEVELS.length) {
                alert("Semua level selesai!");
                switchScreen('screen-menu');
                return;
            }
            
            const lvl = LEVELS[idx];
            gridSize = lvl.size;
            resizeCanvas(); 
            
            // Deep Copy Grid
            state.grid = JSON.parse(JSON.stringify(lvl.grid));
            state.paths = {};
            state.moves = 0;
            state.completed = false;
            
            // Simpan posisi awal (Endpoint)
            for(let r=0; r<gridSize; r++) {
                for(let c=0; c<gridSize; c++) {
                    const val = state.grid[r][c];
                    if(val > 0) {
                        if(!state.paths[val]) state.paths[val] = [];
                    }
                }
            }
            
            document.getElementById('level-display').innerText = idx + 1;
            document.getElementById('moves-display').innerText = 0;
            document.getElementById('level-overlay').classList.add('hidden');
            
            render();
        }

        function resetLevel() { loadLevel(state.levelIdx); }
        function nextLevel() { state.levelIdx++; loadLevel(state.levelIdx); }

        function resizeCanvas() {
            if(!canvas) return;
            const size = Math.min(window.innerWidth - 40, 380);
            canvas.width = size;
            canvas.height = size;
            canvas.style.width = size + 'px';
            canvas.style.height = size + 'px';
            if(gridSize) cellSize = size / gridSize;
            if(state.grid.length > 0) render();
        }

        /* --- 7. INPUT HANDLER (FIXED FOR WEIRD BEHAVIOR) --- */
        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            // Gunakan clientX/Y dari touch atau mouse
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const c = Math.floor(x / cellSize);
            const r = Math.floor(y / cellSize);
            return {r, c};
        }

        function handleStart(e) {
            if(state.completed) return;
            const p = getPos(e);
            if(isOutOfBounds(p)) return;
            
            const baseLevel = LEVELS[state.levelIdx].grid;
            const val = baseLevel[p.r][p.c]; 
            const currentVal = state.grid[p.r][p.c]; 
            
            let colorId = val || currentVal;
            
            if(colorId > 0) {
                state.currentPath = colorId;
                // Mulai path baru dari titik ini
                state.paths[colorId] = [{r: p.r, c: p.c}]; 
                updateGridFromPaths();
                render();
            }
        }

        function handleMove(e) {
            if(!state.currentPath || state.completed) return;
            const p = getPos(e);
            if(isOutOfBounds(p)) return;
            
            const path = state.paths[state.currentPath];
            const last = path[path.length-1];
            
            // Cek jika pindah kotak
            if(last.r !== p.r || last.c !== p.c) {
                
                // FIX: Ijinkan lompat jika gerakan cepat (Interpolasi sederhana: abaikan adjacency check ketat)
                // Cukup cek apakah target valid
                const baseLevel = LEVELS[state.levelIdx].grid;
                const targetBase = baseLevel[p.r][p.c];
                const targetCurrent = state.grid[p.r][p.c];
                
                // Logika: Kotak target harus kosong (0) ATAU bagian dari warna sendiri
                if((targetCurrent === 0) || (targetBase === state.currentPath) || (targetCurrent === state.currentPath)) {
                    
                    // Cek Backtracking (Mundur)
                    const index = path.findIndex(pt => pt.r === p.r && pt.c === p.c);
                    if(index !== -1) {
                        // Potong path jika mundur
                        state.paths[state.currentPath] = path.slice(0, index+1);
                    } else {
                        // Maju: Jangan tabrak endpoint warna LAIN
                        if(targetBase !== 0 && targetBase !== state.currentPath) return;
                        
                        // Tambahkan titik
                        path.push({r: p.r, c: p.c});
                    }
                    
                    updateGridFromPaths();
                    render();
                    checkWin();
                }
            }
        }

        function handleEnd() {
            if(state.currentPath) {
                state.moves++;
                document.getElementById('moves-display').innerText = state.moves;
                state.currentPath = null;
                checkWin();
            }
        }

        function isOutOfBounds(p) {
            return p.r < 0 || p.r >= gridSize || p.c < 0 || p.c >= gridSize;
        }

        function updateGridFromPaths() {
            const base = LEVELS[state.levelIdx].grid;
            // Bersihkan grid dinamis (sisakan base endpoint)
            for(let r=0; r<gridSize; r++) {
                for(let c=0; c<gridSize; c++) {
                    if(base[r][c] === 0) state.grid[r][c] = 0;
                }
            }
            // Gambar ulang semua path
            for(const [colorId, path] of Object.entries(state.paths)) {
                path.forEach(pt => {
                    state.grid[pt.r][pt.c] = parseInt(colorId);
                });
            }
        }

        /* --- 8. RENDERER --- */
        function render() {
            if(!ctx) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Grid Lines
            ctx.strokeStyle = CONFIG.gridLine;
            ctx.lineWidth = 1;
            ctx.beginPath();
            for(let i=0; i<=gridSize; i++) {
                const pos = i * cellSize;
                ctx.moveTo(pos, 0); ctx.lineTo(pos, canvas.height);
                ctx.moveTo(0, pos); ctx.lineTo(canvas.width, pos);
            }
            ctx.stroke();
            
            // Paths
            for(const [colorId, path] of Object.entries(state.paths)) {
                if(path.length < 2) continue;
                
                ctx.strokeStyle = CONFIG.colors[colorId];
                ctx.lineWidth = cellSize * 0.4;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.shadowBlur = 10;
                ctx.shadowColor = CONFIG.colors[colorId];
                
                ctx.beginPath();
                ctx.moveTo(path[0].c * cellSize + cellSize/2, path[0].r * cellSize + cellSize/2);
                for(let i=1; i<path.length; i++) {
                    ctx.lineTo(path[i].c * cellSize + cellSize/2, path[i].r * cellSize + cellSize/2);
                }
                ctx.stroke();
                ctx.shadowBlur = 0;
            }
            
            // Endpoints
            const base = LEVELS[state.levelIdx].grid;
            for(let r=0; r<gridSize; r++) {
                for(let c=0; c<gridSize; c++) {
                    const val = base[r][c];
                    if(val > 0) {
                        const cx = c * cellSize + cellSize/2;
                        const cy = r * cellSize + cellSize/2;
                        
                        ctx.fillStyle = CONFIG.colors[val];
                        
                        // Cek apakah endpoint ini sudah tersambung
                        const path = state.paths[val];
                        const isConnected = path && path.some(pt => pt.r === r && pt.c === c);
                        
                        ctx.beginPath();
                        ctx.arc(cx, cy, cellSize * (isConnected ? 0.35 : 0.25), 0, Math.PI*2);
                        ctx.fill();
                        
                        if(isConnected) {
                            ctx.fillStyle = '#fff';
                            ctx.beginPath();
        
